from typing import List

from Dynamics.Context import Context
from Elements.InteractiveBox import InteractiveBox


class Environment:
    def __init__(self, patterns: list, verbose):
        """
        Symbolic environment that allows to interact and open boxes

        :param patterns: Patterns with which to create boxes
        :param verbose: Print details when executing for debugging
        """
        self.time = 0
        self.verbose = verbose

        # make one box per pattern
        num_boxes = len(patterns)
        if self.verbose:
            print(f"Initialising {num_boxes} boxes")
        self.boxes: list[InteractiveBox] = [InteractiveBox(i, patterns[i]) for i in range(num_boxes)]

        # create context
        self.context = Context(verbose=True)

        # make one step to generate new events
        self.internal_step()

    def step(self, action: List[int]):
        """
        Move forward the environment by one step using the selected action

        :param action: List of box ids to attempt to open
        :return: Reward obtained from acting and context at the end of the environment step
        """

        # apply action and collect reward
        reward = []
        for box_id in action:
            reward.append(self.boxes[box_id].press_button())

        # advance environment and collect context
        context = self.internal_step()

        if self.verbose:
            print("Step Done \n")

        return reward, context

    def internal_step(self):
        """
        Execute one internal step to advance internal environment state
        :return: context resulting from environment exogenous development
        """
        if self.verbose:
            print("Making one internal step to generate events")

        # update each pattern and add developments to context
        self.update_events_patterns()
        # observe context and get new time of context end
        t_current, context = self.context.observe()

        if self.verbose:
            print(f"Advancing time to {t_current}")

        # advance time to match context end
        self.time = t_current
        return context

    def update_events_patterns(self):
        """
        Update event patterns and add to context resulting new events
        TODO: add intermediary function to clarify passing of new events to context
        """
        if self.verbose:
            print("Sampling patterns")

        # obtain list of current ending events generated by patterns
        new_events = []
        for box in self.boxes:
            new_events += box.pattern.get_next(self.time)
            box.update()

        # add newly obtained events to context
        self.context.active_events += new_events

        if self.verbose:
            print(f"\nFinished Sampling {self.context.active_events}")
